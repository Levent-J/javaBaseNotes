#java base tips

	1. java中的所有函数都属于某个类的方法，所有，Java中的main必须有一个外壳类。
	2. Java没有任何无符号类型。
	3. Java中的char是一种表示Unicode编码的字符单元。
	4. 建议不要使用char类型。
	5. 在Java中不区分变量的声明与定义。
	6. 关键字final表示常量。
	7. const是Java的保留字，但是目前并没有使用。
	8. 用static final 定义类常量，用public static final 则其它类也可使用该常量。
	9. >>是符号扩展,>>>是逻辑零扩展。
	10. 用(int)Math.round(x)来对浮点数来进行摄入运算。
	11. 枚举类enum Size {SMALL, MEDIUM, EXTRA_LARGE};Size s = Size.MEDIUM;
	12. java中string不可变，更类似于char*,而不是char[],通常用substring(a,b)来改变string的内容。
	13. string不能用==来判断相等。（在C++中则可以这么做，因为C++的string类重载了==操作。
	14. 只有字符串常量是共享的，而+和substring等操作产生的结果并不是共享的。
	15. 空串与null并不相同。
	16. charAt(index)
	17. codePointAt(index)
	18. char是采用UTF-16编码，所以有的字符用char表示，需要两个代码单元。
	19. 用StringBuilder 来构造字符串效率更高。
	20. JAVA中若想进行格式化输出，可以采用System.out.printf(),也有String.format()
	21. 文件输入输出
	Scanner in = new Scanner(Paths.get("1.txt"));PrintWriter out = new PrintWriter("1.txt");
	22. 不能在嵌套的块中对变量进行重定义。
	23. 在循环中检测两个浮点数是否相等需要格外小心，因为0.1无法精确的用二进制表示。
	24. 从javaSE7开始，case标签还可以是字符串字面值。
	25. java中的break可带标签，用法类似于C中的goto。只能跳出代码块，不能跳入代码块。有待测试。
	26. 大数值运算：BigInter.
	27. 可以用int[] a and int a[]来声明数组，而初始化数组则需要：int[] a = new int[100];
	Int[] a = {1 ,2 ,3}
	初始化匿名数组new int[] {1, 2 ,3}
	28. Arrays.toString(a)
	29. java支持不规则数组。
	30. 可以把Java的对象变量看作C++的对象指针。
	31. java中的一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。
	32. 构造器总是伴随着new操作符来重新设置实例域的目的。
	33. 在java中所有的方法都必须在类里面定义。
	34. Getter and setter 的优点：
		a. 可以改变内部实现，而不不影响除了该类的方法以外的其他方法。
		b. 可以执行错误检查。
	35. 如果需要返回一个可变数据域的拷贝，就应该使用clone。
	36. 一个方法可以访问所属类的所有对象的私有数据。C++也有同样的特性。
	37. 如果实例域被定义为final，构建对象时必须初始化这样的域。并且在之后的操作中，不能再对其进行修改，但是这并不意味着这个final对象是常量！
	38. static为静态域，也可叫做类域，一个类的所有实例将共享一个static域，是可变的；可通过类名进行访问。
	39. 静态方法没有隐式参数，所以其不能向对象实施操作，不能访问实例域，但是可以访问该类的静态域。
	40. 每一个类可以有一个main方法--->单元测试的一种技巧。
	41. 方法得到的是所有参数值得一个拷贝，所以方法不能修改传递给它的任何参数变量的内容。（对象引用的传递类比于指针的值传递）所以一个方法不能让对象参数引用一个新的对象。
	42. 返回类型不是方法签名的一部分，所以不能只以返回类型的不同来重载方法。
	43. 域的默认初始化：0；false；null。
	44. 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器，所以，若再提供额外的构造器后还像拥有简单的默认构造器可以：public employee(){}。
	45. 可以在执行构造器之前先执行赋值操作，可以调用方法对域进行初始化。
	46. 如果构造器的第一个语句形如this(…)这个构造器将调用同一个类的另一个构造器。
	47. 初始化块，若果一个类中有初始化块，就会先运行初始化块，当然大多数做法是直接把这些代码放到构造器中。
	48. 还可以采用static{ int a = 0;…}的形式，在类第一次加载的时候对静态域进行初始化。
	49. 一个类可以使用所属包中的所有类，以及其他包中的公有类。
	50. 出现命名冲突就在每个类名的前面加上完整的包名。
	51. import可以导入静态方法和静态域。如：import static java.lang.System.*,就可直接out.println()。
	52. 如果没没有被public 和 private 修饰，则这个部分（类，方法，变量）值可以被同一个包中的所有方法访问。
	53. 默认的类路径包含了"."目录，然而如果设置了类路径，却忘记了包含"."目录，则程序任然可以通过编译，但不能运行。
	54. "is-a" is the Distinctive feature of inheritance。
	55. 关键词 extends 表示继承.
	56. 在java中所有的继承都是公有继承。
	57. 子类若想覆盖超类的方法，不能直接访问超类的私有域，只能通过关键词super调用超类的方法间接访问（在C++中则是通过采用超类名加上::操作符的形式）。因为super不是一个对象的引用，所以不能将super赋给另一个对象变量。
	58. 使用super调用构造器的语句必须是子类构造器的第一条语句。
	59. 如果子类的构造器没有显示地调用超类的构造器，则将自动地调用超类默认构造器。
	60. 在java中，不需要把方法声明为虚拟方法，动态绑定是默认的处理方式，如果不希望让一个方法具有虚拟特征，可以把它标记为final。
	61. java不支持多继承。
	62. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性，比如在声明子类方法的时候遗漏了public标识符，编译器会把它解释为试图提供更严格的访问权限。
	63. 阻止继承：final类和方法。不过如果将一个类声明为final，只有其中的方法自动变为final，而不包括域。16/3/8 上午11:14  161页
	64. 在将超类转换为子类之前，应该使用instanof进行检查。
	65. 使用abstract 关键字，就不需要实现这个方法。
	66. 包含一个或多个抽象方法的类本身必须被声明为抽象的。
	67. 如果在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类，另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。
	68. 类即使不含抽象方法，也可以将类声明为抽象类。
	69. 抽象类不能被实例化。
	70. 可以定义一个抽象类的对象变量，但是它只能引用非抽象类的对象。（在C++中，只要有一个纯虚函数，这个类就是抽象类。
	71. 子类也不能访问超类的私有域。
	72. java中的受保护部分（protected）对所有子类及同一个包中的所有其它类都可见。
	73. 如果没有明确地指出超类，Object就被认为是这个类的超类。
	74. Objects.equal（a，b），如果两个参数都为null,则返回true,如果其中一个参数为null,则返回false,否则，如果连个参数都不为null,则调用a.equal(b).
##TO BE CONTINUED
	
	
